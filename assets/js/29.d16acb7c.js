(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{444:function(t,v,_){"use strict";_.r(v);var a=_(2),r=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("统一建模语言(Unified Modeling Language，UML)是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。\nUML从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等9种图。")]),t._v(" "),v("h2",{attrs:{id:"类图的概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类图的概述"}},[t._v("#")]),t._v(" 类图的概述")]),t._v(" "),v("p",[t._v("类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。")]),t._v(" "),v("h2",{attrs:{id:"类图的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类图的作用"}},[t._v("#")]),t._v(" 类图的作用")]),t._v(" "),v("ul",[v("li",[t._v("在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解;")]),t._v(" "),v("li",[t._v("类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。")])]),t._v(" "),v("h2",{attrs:{id:"类图的表示方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类图的表示方式"}},[t._v("#")]),t._v(" 类图的表示方式")]),t._v(" "),v("p",[t._v("在UML类图中，类使用包含类名、属性(field)和方法(method)且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name , age和address这3个属性，以及work ()方法。")]),t._v(" "),v("p",[t._v("属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML.类图中表示可见性的符号有三种:·")]),t._v(" "),v("ul",[v("li",[t._v("+:表示public")]),t._v(" "),v("li",[t._v("-∶表示private")]),t._v(" "),v("li",[t._v("#:表示protected")])]),t._v(" "),v("p",[t._v("属性的完整表示方式是:"),v("strong",[t._v("可见性名称︰类型[=缺省值]")]),t._v("\n方法的完整表示方式是:"),v("strong",[t._v("可见性名称(参数列表)〔 :返回类型]")])]),t._v(" "),v("p",[t._v("注意：")]),t._v(" "),v("p",[t._v("1，中括号中的内容表示是可选的\n2，也有将类型放在变量名前面，返回值类型放在方法名前面")]),t._v(" "),v("p",[t._v("上图Demo类定义了三个方法:")]),t._v(" "),v("ul",[v("li",[t._v("method ()方法:修饰符为public，没有参数，没有返回值。")]),t._v(" "),v("li",[t._v("methodl ()方法:修饰符为private，没有参数，返回值类型为string。")]),t._v(" "),v("li",[t._v("method2.()方法:修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为string，返回值类型是int。")])]),t._v(" "),v("h2",{attrs:{id:"类与类之间关系的表示方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类与类之间关系的表示方式"}},[t._v("#")]),t._v(" 类与类之间关系的表示方式")]),t._v(" "),v("h3",{attrs:{id:"关联关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关联关系"}},[t._v("#")]),t._v(" 关联关系")]),t._v(" "),v("p",[t._v("关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。\n关联又可以分为单向关联，双向关联，自关联。")]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("单项关联")])]),t._v(" "),v("p",[t._v("在UML类图中单向关联用一个带箭头的实线表示。表示每个顾客都有一个地址，这通过让customer类持有一个类型为Address的成员变量类实现。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("双向关联")])]),t._v(" "),v("p",[t._v("从所谓的双向关联就是双方各自持有对方类型的成员变量。")]),t._v(" "),v("p",[t._v("在uML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List Product，表示一个顾客可以购买多个商品;在Product类中维护一个customer类型的成员变量表示这个产品被哪个顾客所购买。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("自关联")])]),t._v(" "),v("p",[t._v('自关联在uML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是"自己包含自己”。')])])]),t._v(" "),v("h3",{attrs:{id:"聚合关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#聚合关系"}},[t._v("#")]),t._v(" 聚合关系")]),t._v(" "),v("p",[t._v("聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。\n聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。\n在UML类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。")]),t._v(" "),v("h3",{attrs:{id:"组合关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组合关系"}},[t._v("#")]),t._v(" 组合关系")]),t._v(" "),v("p",[t._v("组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。\n在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。\n在UML类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。")]),t._v(" "),v("h3",{attrs:{id:"依赖关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#依赖关系"}},[t._v("#")]),t._v(" 依赖关系")]),t._v(" "),v("p",[t._v("依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类)中的某些方法来完成一些职责。在UML类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。")]),t._v(" "),v("h3",{attrs:{id:"继承关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#继承关系"}},[t._v("#")]),t._v(" 继承关系")]),t._v(" "),v("p",[t._v("继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。\n在UML类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student类和Teacher类都是Person类的子类")]),t._v(" "),v("h3",{attrs:{id:"实现关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现关系"}},[t._v("#")]),t._v(" 实现关系")]),t._v(" "),v("p",[t._v("实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。\n在UML类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具")])])}),[],!1,null,null,null);v.default=r.exports}}]);