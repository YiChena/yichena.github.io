(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{447:function(v,t,_){"use strict";_.r(t);var a=_(2),r=Object(a.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"java面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java面试题"}},[v._v("#")]),v._v(" Java面试题")]),v._v(" "),t("h3",{attrs:{id:"面向对象的特征"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的特征"}},[v._v("#")]),v._v(" 面向对象的特征")]),v._v(" "),t("h4",{attrs:{id:"封装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[v._v("#")]),v._v(" 封装")]),v._v(" "),t("p",[v._v("利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。")]),v._v(" "),t("p",[v._v("优点:")]),v._v(" "),t("ol",[t("li",[v._v("减少耦合: 可以独立地开发、测试、优化、使用、理解和修改")]),v._v(" "),t("li",[v._v("减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块")]),v._v(" "),t("li",[v._v("有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能")]),v._v(" "),t("li",[v._v("提高软件的可重用性")]),v._v(" "),t("li",[v._v("降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的")])]),v._v(" "),t("h4",{attrs:{id:"继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[v._v("#")]),v._v(" 继承")]),v._v(" "),t("p",[v._v("继承实现了  "),t("strong",[v._v("IS-A")]),v._v("  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。")]),v._v(" "),t("p",[v._v("继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。")]),v._v(" "),t("h4",{attrs:{id:"多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[v._v("#")]),v._v(" 多态")]),v._v(" "),t("p",[v._v("多态分为编译时多态和运行时多态:")]),v._v(" "),t("ul",[t("li",[v._v("编译时多态主要指方法的重载")]),v._v(" "),t("li",[v._v("运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定")])]),v._v(" "),t("p",[v._v("运行时多态有三个条件:")]),v._v(" "),t("ul",[t("li",[v._v("继承")]),v._v(" "),t("li",[v._v("覆盖(重写)")]),v._v(" "),t("li",[v._v("向上转型")])]),v._v(" "),t("h3",{attrs:{id:"final、finalize-和-finally-的不同之处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#final、finalize-和-finally-的不同之处"}},[v._v("#")]),v._v(" final、finalize 和 finally 的不同之处?")]),v._v(" "),t("ul",[t("li",[v._v("final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。")]),v._v(" "),t("li",[v._v("Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。")]),v._v(" "),t("li",[v._v("finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。")])]),v._v(" "),t("h3",{attrs:{id:"注解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注解"}},[v._v("#")]),v._v(" 注解")]),v._v(" "),t("h4",{attrs:{id:"注解的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注解的作用"}},[v._v("#")]),v._v(" 注解的作用？")]),v._v(" "),t("p",[v._v("注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：")]),v._v(" "),t("ul",[t("li",[v._v("生成文档，通过代码里标识的元数据生成javadoc文档。")]),v._v(" "),t("li",[v._v("编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。")]),v._v(" "),t("li",[v._v("编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。")]),v._v(" "),t("li",[v._v("运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。")])]),v._v(" "),t("h4",{attrs:{id:"注解的常见分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注解的常见分类"}},[v._v("#")]),v._v(" 注解的常见分类？")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("Java自带的标准注解")]),v._v("，包括"),t("code",[v._v("@Override")]),v._v("、"),t("code",[v._v("@Deprecated")]),v._v("和"),t("code",[v._v("@SuppressWarnings")]),v._v("，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。")])]),v._v(" "),t("li",[t("p",[v._v("元注解")]),v._v(" "),t("p",[v._v("，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("@Retention")]),v._v("用于标明注解被保留的阶段")]),v._v(" "),t("li",[t("code",[v._v("@Target")]),v._v("用于标明注解使用的范围")]),v._v(" "),t("li",[t("code",[v._v("@Inherited")]),v._v("用于标明注解可继承")]),v._v(" "),t("li",[t("code",[v._v("@Documented")]),v._v("用于标明是否生成javadoc文档")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("自定义注解")]),v._v("，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。")])])]),v._v(" "),t("h3",{attrs:{id:"异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异常"}},[v._v("#")]),v._v(" 异常")]),v._v(" "),t("h4",{attrs:{id:"java-异常类层次结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-异常类层次结构"}},[v._v("#")]),v._v(" Java 异常类层次结构?")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("Throwable")]),v._v(" "),t("p",[v._v("是 Java 语言中所有错误与异常的超类。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Error")]),v._v(" 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。")]),v._v(" "),t("li",[t("strong",[v._v("Exception")]),v._v(" 程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("运行时异常")])])])]),v._v(" "),t("p",[v._v("都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。")]),v._v(" "),t("p",[v._v("运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("非运行时异常")]),v._v(" （编译异常）")])]),v._v(" "),t("p",[v._v("是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常")]),v._v(" "),t("h3",{attrs:{id:"反射"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#反射"}},[v._v("#")]),v._v(" 反射")]),v._v(" "),t("h4",{attrs:{id:"什么是反射"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是反射"}},[v._v("#")]),v._v(" 什么是反射？")]),v._v(" "),t("p",[v._v("JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。")]),v._v(" "),t("h3",{attrs:{id:"java-集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-集合"}},[v._v("#")]),v._v(" Java 集合")]),v._v(" "),t("h4",{attrs:{id:"集合有哪些类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集合有哪些类"}},[v._v("#")]),v._v(" 集合有哪些类？")]),v._v(" "),t("ul",[t("li",[v._v("Set\n"),t("ul",[t("li",[v._v("TreeSet 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。")]),v._v(" "),t("li",[v._v("HashSet 基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。")]),v._v(" "),t("li",[v._v("LinkedHashSet 具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。")])])]),v._v(" "),t("li",[v._v("List\n"),t("ul",[t("li",[v._v("ArrayList 基于动态数组实现，支持随机访问。")]),v._v(" "),t("li",[v._v("Vector 和 ArrayList 类似，但它是线程安全的。")]),v._v(" "),t("li",[v._v("LinkedList 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。")])])]),v._v(" "),t("li",[v._v("Queue\n"),t("ul",[t("li",[v._v("LinkedList 可以用它来实现双向队列。")]),v._v(" "),t("li",[v._v("PriorityQueue 基于堆结构实现，可以用它来实现优先队列。")])])])]),v._v(" "),t("h4",{attrs:{id:"arraylist的底层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arraylist的底层"}},[v._v("#")]),v._v(" ArrayList的底层？")]),v._v(" "),t("p",[t("em",[v._v("ArrayList")]),v._v("实现了"),t("em",[v._v("List")]),v._v("接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入"),t("code",[v._v("null")]),v._v("元素，底层通过"),t("strong",[v._v("数组实现")]),v._v("。除该类未实现同步外，其余跟"),t("em",[v._v("Vector")]),v._v("大致相同。每个"),t("em",[v._v("ArrayList")]),v._v("都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。")]),v._v(" "),t("h4",{attrs:{id:"map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[v._v("#")]),v._v(" Map")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("TreeMap")]),v._v(" 基于红黑树实现。")]),v._v(" "),t("li",[t("code",[v._v("HashMap")]),v._v(" 1.7基于哈希表实现，1.8基于数组+链表+红黑树。")]),v._v(" "),t("li",[t("code",[v._v("HashTable")]),v._v(" 和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高(1.7 ConcurrentHashMap 引入了分段锁, 1.8 引入了红黑树)。")]),v._v(" "),t("li",[t("code",[v._v("LinkedHashMap")]),v._v(" 使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。")])]),v._v(" "),t("h3",{attrs:{id:"java-并发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-并发"}},[v._v("#")]),v._v(" Java 并发")]),v._v(" "),t("h4",{attrs:{id:"多线程的出现是要解决什么问题的-本质什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多线程的出现是要解决什么问题的-本质什么"}},[v._v("#")]),v._v(" 多线程的出现是要解决什么问题的? 本质什么?")]),v._v(" "),t("p",[v._v("CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:")]),v._v(" "),t("ul",[t("li",[v._v("CPU 增加了缓存，以均衡与内存的速度差异；// 导致可见性问题")]),v._v(" "),t("li",[v._v("操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致原子性问题")]),v._v(" "),t("li",[v._v("编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致有序性问题")])]),v._v(" "),t("h4",{attrs:{id:"如何理解并发和并行的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何理解并发和并行的区别"}},[v._v("#")]),v._v(" 如何理解并发和并行的区别?")]),v._v(" "),t("p",[v._v("并发是指一个处理器同时处理多个任务。")]),v._v(" "),t("p",[v._v("并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。")]),v._v(" "),t("h3",{attrs:{id:"java-io"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-io"}},[v._v("#")]),v._v(" Java IO")]),v._v(" "),t("h4",{attrs:{id:"如何从数据传输方式理解io流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何从数据传输方式理解io流"}},[v._v("#")]),v._v(" 如何从数据传输方式理解IO流？")]),v._v(" "),t("p",[v._v("从数据传输方式或者说是运输方式角度看，可以将 IO 类分为:")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("字节流")]),v._v(", 字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码中文汉字是 3 个字节，GBK编码中文汉字是 2 个字节。)")]),v._v(" "),t("li",[t("strong",[v._v("字符流")]),v._v(", 字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。")])]),v._v(" "),t("h4",{attrs:{id:"java-io设计上使用了什么设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-io设计上使用了什么设计模式"}},[v._v("#")]),v._v(" Java IO设计上使用了什么设计模式？")]),v._v(" "),t("p",[t("strong",[v._v("装饰者模式")]),v._v("： 所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("装饰着举例")])])]),v._v(" "),t("p",[v._v("设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。")]),v._v(" "),t("p",[v._v("下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。")]),v._v(" "),t("h4",{attrs:{id:"_5种io模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5种io模型"}},[v._v("#")]),v._v(" 5种IO模型")]),v._v(" "),t("h5",{attrs:{id:"什么是阻塞-什么是同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是阻塞-什么是同步"}},[v._v("#")]),v._v(" 什么是阻塞？什么是同步？")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("阻塞IO 和 非阻塞IO")])])]),v._v(" "),t("p",[v._v("这两个概念是"),t("strong",[v._v("程序级别")]),v._v("的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("同步IO 和 非同步IO")])])]),v._v(" "),t("p",[v._v("这两个概念是"),t("strong",[v._v("操作系统级别")]),v._v("的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。")]),v._v(" "),t("h5",{attrs:{id:"什么是同步阻塞io"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是同步阻塞io"}},[v._v("#")]),v._v(" 什么是同步阻塞IO？")]),v._v(" "),t("p",[v._v("应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("举例理解")])])]),v._v(" "),t("p",[v._v("你早上去买有现炸油条，你点单，之后一直等店家做好，期间你啥其它事也做不了。（你就是应用级别，店家就是操作系统级别， 应用被阻塞了不能做其它事）")]),v._v(" "),t("h3",{attrs:{id:"jvm和调优"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm和调优"}},[v._v("#")]),v._v(" JVM和调优")]),v._v(" "),t("h4",{attrs:{id:"class-forname-和classloader-loadclass-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class-forname-和classloader-loadclass-区别"}},[v._v("#")]),v._v(" Class.forName()和ClassLoader.loadClass()区别?")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("Class.forName()")]),v._v(": 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；")]),v._v(" "),t("li",[t("code",[v._v("ClassLoader.loadClass()")]),v._v(": 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。")]),v._v(" "),t("li",[t("code",[v._v("Class.forName(name, initialize, loader)")]),v._v("带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象")])]),v._v(" "),t("h4",{attrs:{id:"什么是程序计数器-线程私有"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是程序计数器-线程私有"}},[v._v("#")]),v._v(" 什么是程序计数器（线程私有）？")]),v._v(" "),t("p",[v._v("PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("PC寄存器为什么会被设定为线程私有的？")])])]),v._v(" "),t("p",[v._v("多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响")]),v._v(" "),t("h4",{attrs:{id:"什么是虚拟机栈-线程私有"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟机栈-线程私有"}},[v._v("#")]),v._v(" 什么是虚拟机栈（线程私有）？")]),v._v(" "),t("p",[v._v("主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("特点？")])])]),v._v(" "),t("ol",[t("li",[v._v("栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器")]),v._v(" "),t("li",[v._v("JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着"),t("strong",[v._v("入栈")]),v._v("（进栈/压栈），方法执行结束"),t("strong",[v._v("出栈")])]),v._v(" "),t("li",[v._v("栈不存在垃圾回收问题")]),v._v(" "),t("li",[v._v("可以通过参数"),t("code",[v._v("-Xss")]),v._v("来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("该区域有哪些异常")]),v._v("？")])]),v._v(" "),t("ol",[t("li",[v._v("如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 "),t("strong",[v._v("StackOverflowError")]),v._v(" 异常")]),v._v(" "),t("li",[v._v("如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个"),t("strong",[v._v("OutOfMemoryError")]),v._v("异常")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("栈帧的内部结构？")])])]),v._v(" "),t("ol",[t("li",[v._v("局部变量表（Local Variables）")]),v._v(" "),t("li",[v._v("操作数栈（Operand Stack）(或称为表达式栈)")]),v._v(" "),t("li",[v._v("动态链接（Dynamic Linking）：指向运行时常量池的方法引用")]),v._v(" "),t("li",[v._v("方法返回地址（Return Address）：方法正常退出或异常退出的地址")]),v._v(" "),t("li",[v._v("一些附加信息")])]),v._v(" "),t("h3",{attrs:{id:"数据结构和算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法"}},[v._v("#")]),v._v(" 数据结构和算法")]),v._v(" "),t("h4",{attrs:{id:"如何理解基础的数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何理解基础的数据结构"}},[v._v("#")]),v._v(" 如何理解基础的数据结构？")]),v._v(" "),t("p",[v._v("避免孤立的学习知识点，要关联学习。比如实际应用当中，我们经常使用的是"),t("strong",[v._v("查找，排序以及增删改")]),v._v("，这在我们的各种管理系统、数据库系统、操作系统等当中，十分常用，我们通过这个线索将知识点串联起来：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("数组")]),v._v("的下标寻址十分迅速，但计算机的内存是有限的，故数组的长度也是有限的，实际应用当中的数据往往十分庞大；而且无序数组的查找最坏情况需要遍历整个数组；后来人们提出了二分查找，二分查找要求数组的构造一定有序，二分法查找解决了普通数组查找复杂度过高的问题。任何一种数组无法解决的问题就是插入、删除操作比较复杂，因此，在一个增删查改比较频繁的数据结构中，数组不会被优先考虑")]),v._v(" "),t("li",[t("strong",[v._v("普通链表")]),v._v("由于它的结构特点被证明根本不适合进行查找")]),v._v(" "),t("li",[t("strong",[v._v("哈希表")]),v._v("是数组和链表的折中，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也不适合大规模的查找")]),v._v(" "),t("li",[t("strong",[v._v("二叉查找树")]),v._v("因为可能退化成链表，同样不适合进行查找")]),v._v(" "),t("li",[t("strong",[v._v("AVL树")]),v._v("是为了解决二叉查找树可能退化成链表问题。"),t("strong",[v._v("AVL树是严格的平衡二叉树")]),v._v("，平衡条件必须满足（所有节点的左右子树高度差的绝对值不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入与删除次数比较少，但查找多的情况。")]),v._v(" "),t("li",[t("strong",[v._v("红黑树")]),v._v("是二叉查找树和AVL树的折中。它是一种弱平衡二叉树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，"),t("strong",[v._v("红黑树是一种弱平衡二叉树")]),v._v("（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树。")]),v._v(" "),t("li",[t("strong",[v._v("多路查找树")]),v._v(" 是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的(如果元素数量非常多的话，查找就退化成节点内部的线性查找了)，这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。")]),v._v(" "),t("li",[t("strong",[v._v("B树")]),v._v("与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是文件系统及部分非关系型数据库索引。")]),v._v(" "),t("li",[t("strong",[v._v("B+树")]),v._v("在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。通常用于关系型数据库(如Mysql)和操作系统的文件系统中。")]),v._v(" "),t("li",[t("strong",[v._v("B*树")]),v._v("是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针, 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。")]),v._v(" "),t("li",[t("strong",[v._v("R树")]),v._v("是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。")]),v._v(" "),t("li",[t("strong",[v._v("Trie树")]),v._v("是自然语言处理中最常用的数据结构，很多字符串处理任务都会用到。Trie树本身是一种有限状态自动机，还有很多变体。什么模式匹配、正则表达式，都与这有关。")])]),v._v(" "),t("h4",{attrs:{id:"有哪些常见的算法思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有哪些常见的算法思想"}},[v._v("#")]),v._v(" 有哪些常见的算法思想？")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("分治算法")]),v._v(" ：分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解")]),v._v(" "),t("li",[t("strong",[v._v("动态规划算法")]),v._v("： 通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。和分治算法最大的差别：适用于动态规划算法求解的问题经过分解后得到的子问题往往不是相互独立的，而是下一个子阶段的求解是建立在上一个子阶段的解的基础上的。")]),v._v(" "),t("li",[t("strong",[v._v("贪心算法")]),v._v(": 保证每次操作都是局部最优的，并且最后得到的结果是全局最优的")]),v._v(" "),t("li",[t("strong",[v._v("二分法")]),v._v("： 比如重要的二分法，比如二分查找；二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。")]),v._v(" "),t("li",[t("strong",[v._v("搜索算法")]),v._v("： 主要包含BFS，DFS")]),v._v(" "),t("li",[t("strong",[v._v("Backtracking(回溯)")]),v._v("： 属于 DFS, 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法")])]),v._v(" "),t("h4",{attrs:{id:"有哪些常见的排序算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有哪些常见的排序算法"}},[v._v("#")]),v._v(" 有哪些常见的排序算法？")]),v._v(" "),t("p",[t("strong",[v._v("冒泡排序")]),v._v("(Bubble Sort)")]),v._v(" "),t("ul",[t("li",[v._v("它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止")])]),v._v(" "),t("p",[t("strong",[v._v("快速排序")]),v._v("(Quick Sort)")]),v._v(" "),t("ul",[t("li",[v._v("它的基本思想是: 选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。")])]),v._v(" "),t("p",[t("strong",[v._v("插入排序")]),v._v("(Insertion Sort)")]),v._v(" "),t("ul",[t("li",[v._v("直接插入排序(Straight Insertion Sort)的基本思想是: 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。")])]),v._v(" "),t("p",[t("strong",[v._v("Shell排序")]),v._v("(Shell Sort)")]),v._v(" "),t("ul",[t("li",[v._v("希尔排序实质上是一种分组插入方法。它的基本思想是: 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。")])]),v._v(" "),t("p",[t("strong",[v._v("选择排序")]),v._v("(Selection sort)")]),v._v(" "),t("ul",[t("li",[v._v("它的基本思想是: 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。")])]),v._v(" "),t("p",[t("strong",[v._v("堆排序")]),v._v("(Heap Sort)")]),v._v(" "),t("ul",[t("li",[v._v("堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。")])]),v._v(" "),t("p",[t("strong",[v._v("归并排序")]),v._v("(Merge Sort)")]),v._v(" "),t("ul",[t("li",[v._v('将两个的有序数列合并成一个有序数列，我们称之为"归并"。归并排序(Merge Sort)就是利用归并思想对数列进行排序。')])]),v._v(" "),t("p",[t("strong",[v._v("桶排序")]),v._v("(Bucket Sort)")]),v._v(" "),t("ul",[t("li",[v._v("桶排序(Bucket Sort)的原理很简单，将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）")])]),v._v(" "),t("p",[t("strong",[v._v("基数排序")]),v._v("(Radix Sort)")]),v._v(" "),t("ul",[t("li",[v._v("它的基本思想是: 将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是: 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列")])]),v._v(" "),t("h3",{attrs:{id:"数据库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[v._v("#")]),v._v(" 数据库")]),v._v(" "),t("h4",{attrs:{id:"什么是事务-事务基本特性acid"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是事务-事务基本特性acid"}},[v._v("#")]),v._v(" 什么是事务？事务基本特性ACID？")]),v._v(" "),t("p",[v._v("事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。")]),v._v(" "),t("p",[t("strong",[v._v("事务基本特性ACID")]),v._v("?：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("A原子性(atomicity)")]),v._v(" 指的是一个事务中的操作要么全部成功，要么全部失败。")]),v._v(" "),t("li",[t("strong",[v._v("C一致性(consistency)")]),v._v(" 指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设中间sql执行过程中系统崩溃A也不会损失100块，因为事务没有提交，修改也就不会保存到数据库。")]),v._v(" "),t("li",[t("strong",[v._v("I隔离性(isolation)")]),v._v(" 指的是一个事务的修改在最终提交前，对其他事务是不可见的。")]),v._v(" "),t("li",[t("strong",[v._v("D持久性(durability)")]),v._v(" 指的是一旦事务提交，所做的修改就会永久保存到数据库中")])]),v._v(" "),t("h4",{attrs:{id:"数据库中并发一致性问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库中并发一致性问题"}},[v._v("#")]),v._v(" 数据库中并发一致性问题？")]),v._v(" "),t("p",[v._v("在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("丢失修改")])])]),v._v(" "),t("p",[v._v("T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("读脏数据")])])]),v._v(" "),t("p",[v._v("T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("不可重复读")])])]),v._v(" "),t("p",[v._v("T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("幻影读")])])]),v._v(" "),t("p",[v._v("T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。")]),v._v(" "),t("h4",{attrs:{id:"事务的隔离等级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务的隔离等级"}},[v._v("#")]),v._v(" 事务的隔离等级？")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("未提交读(READ UNCOMMITTED)")]),v._v(" 事务中的修改，即使没有提交，对其它事务也是可见的。")]),v._v(" "),t("li",[t("strong",[v._v("提交读(READ COMMITTED)")]),v._v(" 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。")]),v._v(" "),t("li",[t("strong",[v._v("可重复读(REPEATABLE READ)")]),v._v(" 保证在同一个事务中多次读取同样数据的结果是一样的。")]),v._v(" "),t("li",[t("strong",[v._v("可串行化(SERIALIZABLE)")]),v._v(" 强制事务串行执行。")])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[v._v("隔离级别")]),v._v(" "),t("th",{staticStyle:{"text-align":"center"}},[v._v("脏读")]),v._v(" "),t("th",{staticStyle:{"text-align":"center"}},[v._v("不可重复读")]),v._v(" "),t("th",{staticStyle:{"text-align":"center"}},[v._v("幻影读")])])]),v._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[v._v("未提交读")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("√")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("√")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("√")])]),v._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[v._v("提交读")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("×")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("√")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("√")])]),v._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[v._v("可重复读")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("×")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("×")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("√")])]),v._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[v._v("可串行化")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("×")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("×")]),v._v(" "),t("td",{staticStyle:{"text-align":"center"}},[v._v("×")])])])]),v._v(" "),t("h4",{attrs:{id:"acid靠什么保证的呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#acid靠什么保证的呢"}},[v._v("#")]),v._v(" ACID靠什么保证的呢？")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("A原子性(atomicity)")]),v._v(" 由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql")]),v._v(" "),t("li",[t("strong",[v._v("C一致性(consistency)")]),v._v(" 一般由代码层面来保证")]),v._v(" "),t("li",[t("strong",[v._v("I隔离性(isolation)")]),v._v(" 由MVCC来保证")]),v._v(" "),t("li",[t("strong",[v._v("D持久性(durability)")]),v._v(" 由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复")])]),v._v(" "),t("h3",{attrs:{id:"redis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[v._v("#")]),v._v(" Redis")]),v._v(" "),t("h4",{attrs:{id:"什么是redis-为什么用redis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是redis-为什么用redis"}},[v._v("#")]),v._v(" 什么是Redis，为什么用Redis？")]),v._v(" "),t("p",[v._v("Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。")]),v._v(" "),t("ul",[t("li",[v._v("读写性能优异\n"),t("ul",[t("li",[v._v("Redis能读的速度是110000次/s,写的速度是81000次/s （测试条件见下一节）。")])])]),v._v(" "),t("li",[v._v("数据类型丰富\n"),t("ul",[t("li",[v._v("Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。")])])]),v._v(" "),t("li",[v._v("原子性\n"),t("ul",[t("li",[v._v("Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。")])])]),v._v(" "),t("li",[v._v("丰富的特性\n"),t("ul",[t("li",[v._v("Redis支持 publish/subscribe, 通知, key 过期等特性。")])])]),v._v(" "),t("li",[v._v("持久化\n"),t("ul",[t("li",[v._v("Redis支持RDB, AOF等持久化方式")])])]),v._v(" "),t("li",[v._v("发布订阅\n"),t("ul",[t("li",[v._v("Redis支持发布/订阅模式")])])]),v._v(" "),t("li",[v._v("分布式\n"),t("ul",[t("li",[v._v("Redis Cluster")])])])]),v._v(" "),t("h3",{attrs:{id:"mongodb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mongodb"}},[v._v("#")]),v._v(" MongoDB")]),v._v(" "),t("h4",{attrs:{id:"什么是mongodb-为什么使用mongodb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是mongodb-为什么使用mongodb"}},[v._v("#")]),v._v(" 什么是MongoDB？为什么使用MongoDB？")]),v._v(" "),t("p",[v._v("MongoDB是面向文档的NoSQL数据库，用于大量数据存储。MongoDB是一个在2000年代中期问世的数据库。属于NoSQL数据库的类别。以下是一些为什么应该开始使用MongoDB的原因")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("面向文档的")]),v._v("–由于MongoDB是NoSQL类型的数据库，它不是以关系类型的格式存储数据，而是将数据存储在文档中。这使得MongoDB非常灵活，可以适应实际的业务环境和需求。")]),v._v(" "),t("li",[t("strong",[v._v("临时查询")]),v._v("-MongoDB支持按字段，范围查询和正则表达式搜索。可以查询返回文档中的特定字段。")]),v._v(" "),t("li",[t("strong",[v._v("索引")]),v._v("-可以创建索引以提高MongoDB中的搜索性能。MongoDB文档中的任何字段都可以建立索引。")]),v._v(" "),t("li",[t("strong",[v._v("复制")]),v._v("-MongoDB可以提供副本集的高可用性。副本集由两个或多个mongo数据库实例组成。每个副本集成员可以随时充当主副本或辅助副本的角色。主副本是与客户端交互并执行所有读/写操作的主服务器。辅助副本使用内置复制维护主数据的副本。当主副本发生故障时，副本集将自动切换到辅助副本，然后它将成为主服务器。")]),v._v(" "),t("li",[t("strong",[v._v("负载平衡")]),v._v("-MongoDB使用分片的概念，通过在多个MongoDB实例之间拆分数据来水平扩展。MongoDB可以在多台服务器上运行，以平衡负载或复制数据，以便在硬件出现故障时保持系统正常运行")])]),v._v(" "),t("h3",{attrs:{id:"elasticsearch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#elasticsearch"}},[v._v("#")]),v._v(" ElasticSearch")]),v._v(" "),t("h4",{attrs:{id:"elasticsearch是什么-基于lucene的-那么为什么不是直接使用lucene呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#elasticsearch是什么-基于lucene的-那么为什么不是直接使用lucene呢"}},[v._v("#")]),v._v(" ElasticSearch是什么？基于Lucene的，那么为什么不是直接使用Lucene呢？")]),v._v(" "),t("p",[v._v("Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库。Elasticsearch 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目的是使全文检索变得简单，"),t("strong",[v._v("通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API")]),v._v("。")]),v._v(" "),t("p",[v._v("然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎：")]),v._v(" "),t("ul",[t("li",[v._v("一个分布式的实时文档存储，每个字段 可以被索引与搜索")]),v._v(" "),t("li",[v._v("一个分布式实时分析搜索引擎")]),v._v(" "),t("li",[v._v("能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据")])]),v._v(" "),t("p",[v._v("一个ES和数据库的对比")]),v._v(" "),t("h3",{attrs:{id:"常用类库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用类库"}},[v._v("#")]),v._v(" 常用类库")]),v._v(" "),t("h4",{attrs:{id:"平时常用的开发工具库有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#平时常用的开发工具库有哪些"}},[v._v("#")]),v._v(" 平时常用的开发工具库有哪些？")]),v._v(" "),t("ul",[t("li",[v._v("Apache Common\n"),t("ul",[t("li",[v._v("Apache Commons是对JDK的拓展，包含了很多开源的工具，用于解决平时编程经常会遇到的问题，减少重复劳动。")])])]),v._v(" "),t("li",[v._v("Google Guava\n"),t("ul",[t("li",[v._v("Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中。")])])]),v._v(" "),t("li",[v._v("Hutool\n"),t("ul",[t("li",[v._v("国产后起之秀，Hutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率")])])]),v._v(" "),t("li",[v._v("Spring常用工具类\n"),t("ul",[t("li",[v._v("Spring作为常用的开发框架，在Spring框架应用中，排在ApacheCommon，Guava, Huool等通用库后，第二优先级可以考虑使用Spring-core-xxx.jar中的util包")])])])]),v._v(" "),t("h4",{attrs:{id:"lombok工具库用来解决什么问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lombok工具库用来解决什么问题"}},[v._v("#")]),v._v(" Lombok工具库用来解决什么问题？")]),v._v(" "),t("p",[v._v("我们通常需要编写大量代码才能使类变得有用。如以下内容：")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("toString()")]),v._v("方法")]),v._v(" "),t("li",[t("code",[v._v("hashCode()")]),v._v(" and "),t("code",[v._v("equals()")]),v._v("方法")]),v._v(" "),t("li",[t("code",[v._v("Getter")]),v._v(" and "),t("code",[v._v("Setter")]),v._v(" 方法")]),v._v(" "),t("li",[v._v("构造函数")])]),v._v(" "),t("h3",{attrs:{id:"单元测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单元测试"}},[v._v("#")]),v._v(" 单元测试")]),v._v(" "),t("h4",{attrs:{id:"谈谈你对单元测试的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对单元测试的理解"}},[v._v("#")]),v._v(" 谈谈你对单元测试的理解？")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("什么是单元测试")]),v._v("？")])]),v._v(" "),t("p",[v._v("单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("为什么要写单元测试")]),v._v("？")])]),v._v(" "),t("p",[v._v("使用单元测试可以有效地降低程序出错的机率，提供准确的文档，并帮助我们改进设计方案等等。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("什么时候写单元测试")]),v._v("？")])]),v._v(" "),t("p",[v._v("比较推荐单元测试与具体实现代码同步进行这个方案的。只有对需求有一定的理解后才能知道什么是代码的正确性，才能写出有效的单元测试来验证正确性，而能写出一些功能代码则说明对需求有一定理解了。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("单元测试要写多细")]),v._v("？")])]),v._v(" "),t("p",[v._v("单元测试不是越多越好，而是越有效越好！进一步解读就是哪些代码需要有单元测试覆盖：")]),v._v(" "),t("ol",[t("li",[v._v("逻辑复杂的")]),v._v(" "),t("li",[v._v("容易出错的")]),v._v(" "),t("li",[v._v("不易理解的，即使是自己过段时间也会遗忘的，看不懂自己的代码，单元测试代码有助于理解代码的功能和需求")]),v._v(" "),t("li",[v._v("公共代码。比如自定义的所有http请求都会经过的拦截器；工具类等。")]),v._v(" "),t("li",[v._v("核心业务代码。一个产品里最核心最有业务价值的代码应该要有较高的单元测试覆盖率")])]),v._v(" "),t("h3",{attrs:{id:"spring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[v._v("#")]),v._v(" Spring")]),v._v(" "),t("h4",{attrs:{id:"什么是spring框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring框架"}},[v._v("#")]),v._v(" 什么是Spring框架？")]),v._v(" "),t("p",[v._v("Spring是一种轻量级框架，旨在提高开发人员的开发效率以及系统的可维护性。")]),v._v(" "),t("p",[v._v("我们一般说的Spring框架就是Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是核心容器、数据访问/集成、Web、AOP（面向切面编程）、工具、消息和测试模块。比如Core Container中的Core组件是Spring所有组件的核心，Beans组件和Context组件是实现IOC和DI的基础，AOP组件用来实现面向切面编程。")]),v._v(" "),t("p",[v._v("Spring官网列出的Spring的6个特征：")]),v._v(" "),t("ul",[t("li",[v._v("核心技术：依赖注入（DI），AOP，事件（Events），资源，i18n，验证，数据绑定，类型转换，SpEL。")]),v._v(" "),t("li",[v._v("测试：模拟对象，TestContext框架，Spring MVC测试，WebTestClient。")]),v._v(" "),t("li",[v._v("数据访问：事务，DAO支持，JDBC，ORM，编组XML。")]),v._v(" "),t("li",[v._v("Web支持：Spring MVC和Spring WebFlux Web框架。")]),v._v(" "),t("li",[v._v("集成：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。")]),v._v(" "),t("li",[v._v("语言：Kotlin，Groovy，动态语言。")])]),v._v(" "),t("h4",{attrs:{id:"什么是ioc-如何实现的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是ioc-如何实现的"}},[v._v("#")]),v._v(" 什么是IOC? 如何实现的？")]),v._v(" "),t("p",[v._v("IOC（Inversion Of Controll，控制反转）是一种设计思想，就是将原本在程序中手动创建对象的控制权，交给IOC容器来管理，并由IOC容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。IOC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。")]),v._v(" "),t("h4",{attrs:{id:"什么是aop-有哪些aop的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是aop-有哪些aop的概念"}},[v._v("#")]),v._v(" 什么是AOP? 有哪些AOP的概念？")]),v._v(" "),t("p",[v._v("AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。")]),v._v(" "),t("p",[v._v("Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理")]),v._v(" "),t("p",[v._v("当然也可以使用AspectJ，Spring AOP中已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。使用AOP之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样可以大大简化代码量。我们需要增加新功能也方便，提高了系统的扩展性。日志功能、事务管理和权限管理等场景都用到了AOP。")]),v._v(" "),t("p",[t("strong",[v._v("AOP包含的几个概念")])]),v._v(" "),t("ol",[t("li",[v._v("Jointpoint（连接点）：具体的切面点点抽象概念，可以是在字段、方法上，Spring中具体表现形式是PointCut（切入点），仅作用在方法上。")]),v._v(" "),t("li",[v._v("Advice（通知）: 在连接点进行的具体操作，如何进行增强处理的，分为前置、后置、异常、最终、环绕五种情况。")]),v._v(" "),t("li",[v._v("目标对象：被AOP框架进行增强处理的对象，也被称为被增强的对象。")]),v._v(" "),t("li",[v._v("AOP代理：AOP框架创建的对象，简单的说，代理就是对目标对象的加强。Spring中的AOP代理可以是JDK动态代理，也可以是CGLIB代理。")]),v._v(" "),t("li",[v._v("Weaving（织入）：将增强处理添加到目标对象中，创建一个被增强的对象的过程")])]),v._v(" "),t("p",[v._v("总结为一句话就是：在目标对象（target object）的某些方法（jointpoint）添加不同种类的操作（通知、增强操处理），最后通过某些方法（weaving、织入操作）实现一个新的代理目标对象")]),v._v(" "),t("h4",{attrs:{id:"aop-有哪些应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aop-有哪些应用场景"}},[v._v("#")]),v._v(" AOP 有哪些应用场景？")]),v._v(" "),t("p",[v._v("举几个例子：")]),v._v(" "),t("ul",[t("li",[v._v("记录日志(调用方法后记录日志)")]),v._v(" "),t("li",[v._v("监控性能(统计方法运行时间)")]),v._v(" "),t("li",[v._v("权限控制(调用方法前校验是否有权限)")]),v._v(" "),t("li",[v._v("事务管理(调用方法前开启事务，调用方法后提交关闭事务 )")]),v._v(" "),t("li",[v._v("缓存优化(第一次调用查询数据库，将查询结果放入内存对象， 第二次调用，直接从内存对象返回，不需要查询数据库 )")])]),v._v(" "),t("h4",{attrs:{id:"有哪些aop-advice通知的类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有哪些aop-advice通知的类型"}},[v._v("#")]),v._v(" 有哪些AOP Advice通知的类型？")]),v._v(" "),t("p",[v._v("特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("前置通知")]),v._v("（Before advice） ： 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。")]),v._v(" "),t("li",[t("strong",[v._v("后置通知")]),v._v("（After advice） ：这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。")]),v._v(" "),t("li",[t("strong",[v._v("返回后通知")]),v._v("（After return advice） ：这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。")]),v._v(" "),t("li",[t("strong",[v._v("环绕通知")]),v._v("（Around advice） ：这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。")]),v._v(" "),t("li",[t("strong",[v._v("抛出异常后通知")]),v._v("（After throwing advice） ：仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。")])]),v._v(" "),t("h4",{attrs:{id:"aop-有哪些实现方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aop-有哪些实现方式"}},[v._v("#")]),v._v(" AOP 有哪些实现方式？")]),v._v(" "),t("p",[v._v("实现 AOP 的技术，主要分为两大类：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("静态代理")]),v._v(" "),t("p",[v._v("- 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；")]),v._v(" "),t("ul",[t("li",[v._v("编译时编织（特殊编译器实现）")]),v._v(" "),t("li",[v._v("类加载时编织（特殊的类加载器实现）。")])])]),v._v(" "),t("li",[t("p",[v._v("动态代理")]),v._v(" "),t("p",[v._v("- 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。")]),v._v(" "),t("ul",[t("li",[v._v("JDK 动态代理\n"),t("ul",[t("li",[v._v("JDK Proxy 是 Java 语言自带的功能，无需通过加载第三方类实现；")]),v._v(" "),t("li",[v._v("Java 对 JDK Proxy 提供了稳定的支持，并且会持续的升级和更新，Java 8 版本中的 JDK Proxy 性能相比于之前版本提升了很多；")]),v._v(" "),t("li",[v._v("JDK Proxy 是通过拦截器加反射的方式实现的；")]),v._v(" "),t("li",[v._v("JDK Proxy 只能代理实现接口的类；")]),v._v(" "),t("li",[v._v("JDK Proxy 实现和调用起来比较简单；")])])]),v._v(" "),t("li",[v._v("CGLIB\n"),t("ul",[t("li",[v._v("CGLib 是第三方提供的工具，基于 ASM 实现的，性能比较高；")]),v._v(" "),t("li",[v._v("CGLib 无需通过接口来实现，它是针对类实现代理，主要是对指定的类生成一个子类，它是通过实现子类的方式来完成调用的")])])])])])]),v._v(" "),t("h4",{attrs:{id:"spring中的bean的作用域有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring中的bean的作用域有哪些"}},[v._v("#")]),v._v(" Spring中的bean的作用域有哪些？")]),v._v(" "),t("ol",[t("li",[v._v("singleton：唯一bean实例，Spring中的bean默认都是单例的。")]),v._v(" "),t("li",[v._v("prototype：每次请求都会创建一个新的bean实例。")]),v._v(" "),t("li",[v._v("request：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。")]),v._v(" "),t("li",[v._v("session：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效。")]),v._v(" "),t("li",[v._v("global-session：全局session作用域，仅仅在基于Portlet的Web应用中才有意义，Spring5中已经没有了。Portlet是能够生成语义代码（例如HTML）片段的小型Java Web插件。它们基于Portlet容器，可以像Servlet一样处理HTTP请求。但是与Servlet不同，每个Portlet都有不同的会话")])]),v._v(" "),t("h4",{attrs:{id:"说说自己对于spring-mvc的了解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说说自己对于spring-mvc的了解"}},[v._v("#")]),v._v(" 说说自己对于Spring MVC的了解？")]),v._v(" "),t("p",[v._v("MVC是一种设计模式，Spring MVC是一款很优秀的MVC框架。Spring MVC可以帮助我们进行更简洁的Web层的开发，并且它天生与Spring框架集成。Spring MVC下我们一般把后端项目分为Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层（控制层，返回数据给前台页面）。")]),v._v(" "),t("h4",{attrs:{id:"spring-mvc的工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc的工作原理"}},[v._v("#")]),v._v(" Spring MVC的工作原理")]),v._v(" "),t("p",[v._v("流程说明：")]),v._v(" "),t("p",[v._v("1.客户端（浏览器）发送请求，直接请求到DispatcherServlet。")]),v._v(" "),t("p",[v._v("2.DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler。")]),v._v(" "),t("p",[v._v("3.解析到对应的Handler（也就是我们平常说的Controller控制器）。")]),v._v(" "),t("p",[v._v("4.HandlerAdapter会根据Handler来调用真正的处理器来处理请求和执行相对应的业务逻辑。")]),v._v(" "),t("p",[v._v("5.处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View。")]),v._v(" "),t("p",[v._v("6.ViewResolver会根据逻辑View去查找实际的View。")]),v._v(" "),t("p",[v._v("7.DispatcherServlet把返回的Model传给View（视图渲染）。")]),v._v(" "),t("p",[v._v("8.把View返回给请求者（浏览器）。")]),v._v(" "),t("h4",{attrs:{id:"spring框架中用到了哪些设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring框架中用到了哪些设计模式"}},[v._v("#")]),v._v(" Spring框架中用到了哪些设计模式？")]),v._v(" "),t("p",[v._v("举几个例子")]),v._v(" "),t("p",[v._v("1.工厂设计模式：Spring使用工厂模式通过BeanFactory和ApplicationContext创建bean对象。")]),v._v(" "),t("p",[v._v("2.代理设计模式：Spring AOP功能的实现。")]),v._v(" "),t("p",[v._v("3.单例设计模式：Spring中的bean默认都是单例的。")]),v._v(" "),t("p",[v._v("4.模板方法模式：Spring中的jdbcTemplate、hibernateTemplate等以Template结尾的对数据库操作的类，它们就使用到了模板模式。")]),v._v(" "),t("p",[v._v("5.包装器设计模式：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。")]),v._v(" "),t("p",[v._v("6.观察者模式：Spring事件驱动模型就是观察者模式很经典的一个应用。")]),v._v(" "),t("p",[v._v("7.适配器模式：Spring AOP的增强或通知（Advice）使用到了适配器模式、Spring MVC中也是用到了适配器模式适配Controller")]),v._v(" "),t("h4",{attrs:{id:"将一个类声明为spring的bean的注解有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#将一个类声明为spring的bean的注解有哪些"}},[v._v("#")]),v._v(" 将一个类声明为Spring的bean的注解有哪些？")]),v._v(" "),t("p",[v._v("我们一般使用@Autowired注解去自动装配bean。而想要把一个类标识为可以用@Autowired注解自动装配的bean，可以采用以下的注解实现：")]),v._v(" "),t("p",[v._v("1.@Component注解。通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪一个层，可以使用@Component注解标注。")]),v._v(" "),t("p",[v._v("2.@Repository注解。对应持久层，即Dao层，主要用于数据库相关操作。")]),v._v(" "),t("p",[v._v("3.@Service注解。对应服务层，即Service层，主要涉及一些复杂的逻辑，需要用到Dao层（注入）。")]),v._v(" "),t("p",[v._v("4.@Controller注解。对应Spring MVC的控制层，即Controller层，主要用于接受用户请求并调用Service层的方法返回数据给前端页面。")]),v._v(" "),t("h3",{attrs:{id:"springboot"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springboot"}},[v._v("#")]),v._v(" SpringBoot")]),v._v(" "),t("h4",{attrs:{id:"什么是springboot"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是springboot"}},[v._v("#")]),v._v(" 什么是SpringBoot？")]),v._v(" "),t("p",[v._v("Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。")]),v._v(" "),t("ul",[t("li",[v._v("用来简化Spring应用的初始搭建以及开发过程，使用特定的方式来进行配置")]),v._v(" "),t("li",[v._v("创建独立的Spring引用程序main方法运行")]),v._v(" "),t("li",[v._v("嵌入的tomcat无需部署war文件")]),v._v(" "),t("li",[v._v("简化maven配置")]),v._v(" "),t("li",[v._v("自动配置Spring添加对应的功能starter自动化配置")]),v._v(" "),t("li",[v._v("SpringBoot来简化Spring应用开发，约定大于配置，去繁化简")])]),v._v(" "),t("h4",{attrs:{id:"为什么使用springboot"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用springboot"}},[v._v("#")]),v._v(" 为什么使用SpringBoot？")]),v._v(" "),t("ul",[t("li",[v._v("独立运行")])]),v._v(" "),t("p",[v._v("Spring Boot 而且内嵌了各种 servlet 容器，Tomcat、Jetty 等，现在不再需要打成war 包部署到容器中，Spring Boot 只要打成一个可执行的 jar 包就能独立运行，所有的依赖包都在一个 jar 包内。")]),v._v(" "),t("ul",[t("li",[v._v("简化配置")])]),v._v(" "),t("p",[v._v("spring-boot-starter-web 启动器自动依赖其他组件，简少了 maven 的配置。")]),v._v(" "),t("ul",[t("li",[v._v("自动配置")])]),v._v(" "),t("p",[v._v("Spring Boot 能根据当前类路径下的类、jar 包来自动配置 bean，如添加一个 spring")]),v._v(" "),t("p",[v._v("boot-starter-web 启动器就能拥有 web 的功能，无需其他配置。")]),v._v(" "),t("ul",[t("li",[v._v("无代码生成和XML配置")])]),v._v(" "),t("p",[v._v("Spring Boot 配置过程中无代码生成，也无需 XML 配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是 Spring4.x 的核心功能之一。")]),v._v(" "),t("ul",[t("li",[v._v("应用监控")])]),v._v(" "),t("p",[v._v("Spring Boot 提供一系列端点可以监控服务及应用，做健康检测")]),v._v(" "),t("h4",{attrs:{id:"spring、spring-mvc和springboot有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring、spring-mvc和springboot有什么区别"}},[v._v("#")]),v._v(" Spring、Spring MVC和SpringBoot有什么区别？")]),v._v(" "),t("ul",[t("li",[v._v("Spring")])]),v._v(" "),t("p",[v._v("Spring最重要的特征是依赖注入。所有Spring Modules不是依赖注入就是IOC控制反转。")]),v._v(" "),t("p",[v._v("当我们恰当的使用DI或者是IOC的时候，可以开发松耦合应用。")]),v._v(" "),t("ul",[t("li",[v._v("Spring MVC")])]),v._v(" "),t("p",[v._v("Spring MVC提供了一种分离式的方法来开发Web应用。通过运用像DispatcherServelet，ModelAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变的非常简单。")]),v._v(" "),t("ul",[t("li",[v._v("SpringBoot")])]),v._v(" "),t("p",[v._v("Spring和Spring MVC的问题在于需要配置大量的参数。")]),v._v(" "),t("p",[v._v("SpringBoot通过一个自动配置和启动的项来解决这个问题")]),v._v(" "),t("h4",{attrs:{id:"springboot自动配置的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springboot自动配置的原理"}},[v._v("#")]),v._v(" SpringBoot自动配置的原理?")]),v._v(" "),t("p",[v._v("在Spring程序main方法中，添加@SpringBootApplication或者@EnableAutoConfiguration会自动去maven中读取每个starter中的spring.factories文件，该文件里配置了所有需要被创建的Spring容器中的bean")]),v._v(" "),t("h4",{attrs:{id:"spring-boot的核心注解是哪些-他主由哪几个注解组成的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot的核心注解是哪些-他主由哪几个注解组成的"}},[v._v("#")]),v._v(" Spring Boot的核心注解是哪些？他主由哪几个注解组成的？")]),v._v(" "),t("p",[v._v("启动类上面的注解是@SpringBootApplication，他也是SpringBoot的核心注解，主要组合包含了以下3个注解：")]),v._v(" "),t("ul",[t("li",[v._v("@SpringBootConfiguration：组合了@Configuration注解，实现配置文件的功能；")]),v._v(" "),t("li",[v._v("@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置的功能：")]),v._v(" "),t("li",[v._v("@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})；")]),v._v(" "),t("li",[v._v("@ComponentScan：Spring组件扫描。")])]),v._v(" "),t("h4",{attrs:{id:"springboot的核心配置文件有哪几个-他们的区别是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springboot的核心配置文件有哪几个-他们的区别是什么"}},[v._v("#")]),v._v(" SpringBoot的核心配置文件有哪几个？他们的区别是什么？")]),v._v(" "),t("p",[v._v("SpringBoot的核心配置文件是application和bootstrap配置文件。")]),v._v(" "),t("p",[v._v("application配置文件这个容易理解，主要用于Spring Boot项目的自动化配置。")]),v._v(" "),t("p",[v._v("bootstrap配置文件有以下几个应用场景：")]),v._v(" "),t("ul",[t("li",[v._v("使用Spring Cloud Config配置中心时，这时需要在bootstrap配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；")]),v._v(" "),t("li",[v._v("一些固定的不能被覆盖的属性；")]),v._v(" "),t("li",[v._v("一些加密/解密的场景；")])]),v._v(" "),t("h3",{attrs:{id:"spring-security"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-security"}},[v._v("#")]),v._v(" Spring Security")]),v._v(" "),t("h4",{attrs:{id:"什么是spring-security-核心功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring-security-核心功能"}},[v._v("#")]),v._v(" 什么是Spring Security？核心功能？")]),v._v(" "),t("p",[v._v("Spring Security是基于Spring的安全框架.它提供全面的安全性解决方案,同时在Web请求级别和调用级别确认和授权.在Spring Framework基础上,Spring Security充分利用了依赖注入(DI)和面向切面编程(AOP)功能,为应用系统提供声明式的安全访问控制功能,建晒了为企业安全控制编写大量重复代码的工作,是一个轻量级的安全框架,并且很好集成Spring MVC")]),v._v(" "),t("p",[v._v("spring security 的核心功能主要包括：")]),v._v(" "),t("ul",[t("li",[v._v("认证(Authentication)：指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。")]),v._v(" "),t("li",[v._v("授权(Authorization)：指的是验证某个用户是否有权限执行某个操作")]),v._v(" "),t("li",[v._v("攻击防护：指的是防止伪造身份")])]),v._v(" "),t("h4",{attrs:{id:"spring-security的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-security的原理"}},[v._v("#")]),v._v(" Spring Security的原理?")]),v._v(" "),t("p",[v._v("简单谈谈其中的要点")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("基于Filter技术实现?")])])]),v._v(" "),t("p",[v._v("首先SpringSecurity是基于Filter技术实现的。Spring通过DelegatingFilterProxy建立Web容器和Spring ApplicationContext的联系，而SpringSecurity使用FilterChainProxy 注册SecurityFilterChain。")]),v._v(" "),t("h3",{attrs:{id:"tomcat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tomcat"}},[v._v("#")]),v._v(" Tomcat")]),v._v(" "),t("h4",{attrs:{id:"tomcat整体架构的设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tomcat整体架构的设计"}},[v._v("#")]),v._v(" Tomcat整体架构的设计？")]),v._v(" "),t("p",[t("strong",[v._v("Server")]),v._v(": 表示服务器，它提供了一种优雅的方式来启动和停止整个系统，不必单独启停连接器和容器；它是Tomcat构成的顶级构成元素，所有一切均包含在Server中；")]),v._v(" "),t("p",[t("strong",[v._v("Service")]),v._v(": 表示服务，Server可以运行多个服务。比如一个Tomcat里面可运行订单服务、支付服务、用户服务等等；Server的实现类StandardServer可以包含一个到多个Services, Service的实现类为StandardService调用了容器(Container)接口，其实是调用了Servlet Engine(引擎)，而且StandardService类中也指明了该Service归属的Server;")]),v._v(" "),t("p",[t("strong",[v._v("Container")]),v._v(": 表示容器，可以看做Servlet容器；引擎(Engine)、主机(Host)、上下文(Context)和Wraper均继承自Container接口，所以它们都是容器。")]),v._v(" "),t("ul",[t("li",[v._v("Engine -- 引擎")]),v._v(" "),t("li",[v._v("Host -- 主机")]),v._v(" "),t("li",[v._v("Context -- 上下文")]),v._v(" "),t("li",[v._v("Wrapper -- 包装器")])]),v._v(" "),t("p",[t("strong",[v._v("Connector")]),v._v(": 表示连接器, "),t("strong",[v._v("它将Service和Container连接起来")]),v._v("，首先它需要注册到一个Service，它的作用就是把来自客户端的请求转发到Container(容器)，这就是它为什么称作连接器, 它支持的协议如下：")]),v._v(" "),t("ul",[t("li",[v._v("支持AJP协议")]),v._v(" "),t("li",[v._v("支持Http协议")]),v._v(" "),t("li",[v._v("支持Https协议")])]),v._v(" "),t("p",[t("strong",[v._v("Service内部")]),v._v("还有各种支撑组件，下面简单罗列一下这些组件")]),v._v(" "),t("ul",[t("li",[v._v("Manager -- 管理器，用于管理会话Session")]),v._v(" "),t("li",[v._v("Logger -- 日志器，用于管理日志")]),v._v(" "),t("li",[v._v("Loader -- 加载器，和类加载有关，只会开放给Context所使用")]),v._v(" "),t("li",[v._v("Pipeline -- 管道组件，配合Valve实现过滤器功能")]),v._v(" "),t("li",[v._v("Valve -- 阀门组件，配合Pipeline实现过滤器功能")]),v._v(" "),t("li",[v._v("Realm -- 认证授权组件")])]),v._v(" "),t("h4",{attrs:{id:"tomcat-一个请求的处理流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tomcat-一个请求的处理流程"}},[v._v("#")]),v._v(" Tomcat 一个请求的处理流程？")]),v._v(" "),t("p",[v._v("假设来自客户的请求为：http://localhost:8080/test/index.jsp 请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector,然后")]),v._v(" "),t("ul",[t("li",[v._v("Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应")]),v._v(" "),t("li",[v._v("Engine获得请求localhost:8080/test/index.jsp，匹配它所有虚拟主机Host")]),v._v(" "),t("li",[v._v("Engine匹配到名为localhost的Host(即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机)")]),v._v(" "),t("li",[v._v("localhost Host获得请求/test/index.jsp，匹配它所拥有的所有Context")]),v._v(" "),t("li",[v._v('Host匹配到路径为/test的Context(如果匹配不到就把该请求交给路径名为""的Context去处理)')]),v._v(" "),t("li",[v._v('path="/test"的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet')]),v._v(" "),t("li",[v._v("Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类，构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法")]),v._v(" "),t("li",[v._v("Context把执行完了之后的HttpServletResponse对象返回给Host")]),v._v(" "),t("li",[v._v("Host把HttpServletResponse对象返回给Engine")]),v._v(" "),t("li",[v._v("Engine把HttpServletResponse对象返回给Connector")]),v._v(" "),t("li",[v._v("Connector把HttpServletResponse对象返回给客户browser")])]),v._v(" "),t("h3",{attrs:{id:"git"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#git"}},[v._v("#")]),v._v(" Git")]),v._v(" "),t("h4",{attrs:{id:"平时是怎么提交代码的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#平时是怎么提交代码的"}},[v._v("#")]),v._v(" 平时是怎么提交代码的？")]),v._v(" "),t("ul",[t("li",[v._v("第零步: 工作区与仓库保持一致")]),v._v(" "),t("li",[v._v("第一步: 文件增删改，变为已修改状态")]),v._v(" "),t("li",[v._v("第二步: git add ，变为已暂存状态")])]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("$ git status\n$ git add --all # 当前项目下的所有更改\n$ git add .  # 当前目录下的所有更改\n$ git add xx/xx.py xx/xx2.py  # 添加某几个文件\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br"),t("span",{staticClass:"line-number"},[v._v("4")]),t("br")])]),t("ul",[t("li",[v._v("第三步: git commit，变为已提交状态")])]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v('$ git commit -m "<这里写commit的描述>"\n')])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("ul",[t("li",[v._v("第四步: git push，变为已推送状态")])]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("$ git push -u origin master # 第一次需要关联上\n$ git push # 之后再推送就不用指明应该推送的远程分支了\n$ git branch # 可以查看本地仓库的分支\n$ git branch -a # 可以查看本地仓库和本地远程仓库(远程仓库的本地镜像)的所有分支\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br"),t("span",{staticClass:"line-number"},[v._v("4")]),t("br")])]),t("ul",[t("li",[v._v("在某个分支下，我最常用的操作如下")])]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("$ git status\n$ git add -a\n$ git status\n$ git commit -m 'xxx'\n$ git pull --rebase\n$ git push origin xxbranch\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br"),t("span",{staticClass:"line-number"},[v._v("4")]),t("br"),t("span",{staticClass:"line-number"},[v._v("5")]),t("br"),t("span",{staticClass:"line-number"},[v._v("6")]),t("br")])]),t("h3",{attrs:{id:"spring-cloud"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud"}},[v._v("#")]),v._v(" Spring Cloud")]),v._v(" "),t("h4",{attrs:{id:"什么是微服务-谈谈你对微服务的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是微服务-谈谈你对微服务的理解"}},[v._v("#")]),v._v(" 什么是微服务？谈谈你对微服务的理解？")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("微服务")])])]),v._v(" "),t("p",[v._v("以前所有的代码都放在同一个工程中、部署在同一个服务器、同一项目的不同模块不同功能互相抢占资源，微服务就是将工程根据不同的业务规则拆分成微服务，部署在不同的服务器上，服务之间相互调用，java中有的微服务有dubbo(只能用来做微服务)、springcloud( 提供了服务的发现、断路器等)。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("微服务的特点")]),v._v("：")])]),v._v(" "),t("ol",[t("li",[v._v("按业务划分为一个独立运行的程序，即服务单元")]),v._v(" "),t("li",[v._v("服务之间通过HTTP协议相互通信")]),v._v(" "),t("li",[v._v("自动化部署")]),v._v(" "),t("li",[v._v("可以用不同的编程语言")]),v._v(" "),t("li",[v._v("可以用不同的存储技术")]),v._v(" "),t("li",[v._v("服务集中化管理")]),v._v(" "),t("li",[v._v("微服务是一个分布式系统")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("微服务的优势")])])]),v._v(" "),t("ol",[t("li",[v._v("将一个复杂的业务拆分为若干小的业务，将复杂的业务简单化，新人只需要了解他所接管的服务的代码，减少了新人的学习成本。")]),v._v(" "),t("li",[v._v("由于微服务是分布式服务，服务于服务之间没有任何耦合。微服务系统的微服务单元具有很强的横向拓展能力。")]),v._v(" "),t("li",[v._v("服务于服务之间采用HTTP网络通信协议来通信，单个服务内部高度耦合，服务与服务之间完全独立，无耦合。这使得微服务可以采用任何的开发语言和技术来实现，提高开发效率、降低开发成本。")]),v._v(" "),t("li",[v._v("微服务是按照业务进行拆分的，并有坚实的服务边界，若要重写某一业务代码，不需了解所有业务，重写简单。")]),v._v(" "),t("li",[v._v("微服务的每个服务单元是独立部署的，即独立运行在某个进程中，微服务的修改和部署对其他服务没有影响。")]),v._v(" "),t("li",[v._v("微服务在CAP理论中采用的AP架构，具有高可用分区容错特点。高可用主要体现在系统7x24不间断服务，他要求系统有大量的服务器集群，从而提高系统的负载能力。分区容错也使得系统更加健壮。")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("微服务的不足")])])]),v._v(" "),t("ol",[t("li",[v._v("微服务的复杂度：构建一个微服务比较复杂，服务与服务之间通过HTTP协议或其他消息传递机制通信，开发者要选出最佳的通信机制，并解决网络服务差时带来的风险。 2.分布式事物：将事物分成多阶段提交，如果一阶段某一节点失败仍会导致数据不正确。如果事物涉及的节点很多，某一节点的网络出现异常会导致整个事务处于阻塞状态，大大降低数据库的性能。")]),v._v(" "),t("li",[v._v("服务划分：将一个完整的系统拆分成很多个服务，是一件非常困难的事，因为这涉及了具体的业务场景")]),v._v(" "),t("li",[v._v("服务部署：最佳部署容器Docker")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("微服务和SOA的关系")])])]),v._v(" "),t("p",[v._v("微服务相对于和ESB联系在一起的SOA轻便敏捷的多，微服务将复杂的业务组件化，也是一种面向服务思想的体现。对于微服务来说，它是SOA的一种体现，但是它比ESB实现的SOA更加轻便、敏捷和简单。")]),v._v(" "),t("h4",{attrs:{id:"什么是spring-cloud"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring-cloud"}},[v._v("#")]),v._v(" 什么是Spring Cloud？")]),v._v(" "),t("p",[v._v("Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。")]),v._v(" "),t("p",[v._v("Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("SpringCloud的优点")])])]),v._v(" "),t("ol",[t("li",[v._v("耦合度比较低。不会影响其他模块的开发。")]),v._v(" "),t("li",[v._v("减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。")]),v._v(" "),t("li",[v._v("配置比较简单，基本用注解就能实现，不用使用过多的配置文件。")]),v._v(" "),t("li",[v._v("微服务跨平台的，可以用任何一种语言开发。")]),v._v(" "),t("li",[v._v("每个微服务可以有自己的独立的数据库也有用公共的数据库。")]),v._v(" "),t("li",[v._v("直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("SpringCloud的缺点")])])]),v._v(" "),t("ol",[t("li",[v._v("部署比较麻烦，给运维工程师带来一定的麻烦。")]),v._v(" "),t("li",[v._v("针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。")]),v._v(" "),t("li",[v._v("系统集成测试比较麻烦")]),v._v(" "),t("li",[v._v("性能的监控比较麻烦。")])]),v._v(" "),t("h4",{attrs:{id:"springcloud中的组件有那些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springcloud中的组件有那些"}},[v._v("#")]),v._v(" SpringCloud中的组件有那些？")]),v._v(" "),t("p",[v._v("说出主要的组件：")]),v._v(" "),t("ul",[t("li",[v._v("Spring Cloud Eureka,服务注册中心,特性有失效剔除、服务保护")]),v._v(" "),t("li",[v._v("Spring Cloud Zuul,API服务网关,功能有路由分发和过滤")]),v._v(" "),t("li",[v._v("Spring Cloud Config,分布式配置中心，支持本地仓库、SVN、Git、Jar包内配置等模式")]),v._v(" "),t("li",[v._v("Spring Cloud Ribbon,客户端负载均衡,特性有区域亲和,重试机制")]),v._v(" "),t("li",[v._v("Spring Cloud Hystrix,客户端容错保护,特性有服务降级、服务熔断、请求缓存、请求合并、依赖隔离")]),v._v(" "),t("li",[v._v("Spring Cloud Feign,声明式服务调用本质上就是Ribbon+Hystrix")]),v._v(" "),t("li",[v._v("Spring Cloud Stream,消息驱动,有Sink、Source、Processor三种通道,特性有订阅发布、消费组、消息分区")]),v._v(" "),t("li",[v._v("Spring Cloud Bus,消息总线,配合Config仓库修改的一种Stream实现，")]),v._v(" "),t("li",[v._v("Spring Cloud Sleuth,分布式服务追踪,需要搞清楚TraceID和SpanID以及抽样,如何与ELK整合")])]),v._v(" "),t("h4",{attrs:{id:"具体说说springcloud主要项目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#具体说说springcloud主要项目"}},[v._v("#")]),v._v(" 具体说说SpringCloud主要项目?")]),v._v(" "),t("p",[v._v('Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架"Spring Boot化"的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。')]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Spring Cloud Config")]),v._v(" Config能够管理所有微服务的配置文件")])]),v._v(" "),t("p",[v._v("集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Spring Cloud Netflix")])])]),v._v(" "),t("p",[v._v("Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。")]),v._v(" "),t("ol",[t("li",[v._v("Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；")]),v._v(" "),t("li",[v._v("Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；")]),v._v(" "),t("li",[v._v("Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；")]),v._v(" "),t("li",[v._v("Feign：基于Ribbon和Hystrix的声明式服务调用组件；")]),v._v(" "),t("li",[v._v("Zuul：API网关组件，对请求提供路由及过滤功能。")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Spring Cloud Bus")])])]),v._v(" "),t("ol",[t("li",[v._v("用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置信息。")]),v._v(" "),t("li",[v._v("简单来说就是修改了配置文件，发送一次请求，所有客户端便会重新读取配置文件（需要利用中间插件MQ）。")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Spring Cloud Consul")])])]),v._v(" "),t("p",[v._v("Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。使用起来也较为简单。Consul 使用 Go 语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Spring Cloud Security")])])]),v._v(" "),t("p",[v._v("Spring Cloud Security提供了一组原语，用于构建安全的应用程序和服务，而且操作简便。可以在外部（或集中）进行大量配置的声明性模型有助于实现大型协作的远程组件系统，通常具有中央身份管理服务。它也非常易于在Cloud Foundry等服务平台中使用。在Spring Boot和Spring Security OAuth2的基础上，可以快速创建实现常见模式的系统，如单点登录，令牌中继和令牌交换。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Spring Cloud Sleuth")])])]),v._v(" "),t("p",[v._v("在微服务中，通常根据业务模块分服务，项目中前端发起一个请求，后端可能跨几个服务调用才能完成这个请求（如下图）。如果系统越来越庞大，服务之间的调用与被调用关系就会变得很复杂，假如一个请求中需要跨几个服务调用，其中一个服务由于网络延迟等原因挂掉了，那么这时候我们需要分析具体哪一个服务出问题了就会显得很困难。Spring Cloud Sleuth服务链路跟踪功能就可以帮助我们快速的发现错误根源以及监控分析每条请求链路上的性能等等。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Spring Cloud Stream")])])]),v._v(" "),t("p",[v._v("轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Spring Cloud Task")])])]),v._v(" "),t("p",[v._v("Spring Cloud Task的目标是为Spring Boot应用程序提供创建短运行期微服务的功能。在Spring Cloud Task中，我们可以灵活地动态运行任何任务，按需分配资源并在任务完成后检索结果。Tasks是Spring Cloud Data Flow中的一个基础项目，允许用户将几乎任何Spring Boot应用程序作为一个短期任务执行。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Spring Cloud Zookeeper")])])]),v._v(" "),t("ol",[t("li",[v._v("SpringCloud支持三种注册方式Eureka， Consul(go语言编写)，zookeeper")]),v._v(" "),t("li",[v._v("Spring Cloud Zookeeper是基于Apache Zookeeper的服务治理组件。")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Spring Cloud Gateway")])])]),v._v(" "),t("p",[v._v("Spring cloud gateway是spring官方基于Spring 5.0、Spring Boot2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式，Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且还基于Filer链的方式提供了网关基本的功能，例如：安全、监控/埋点、限流等。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Spring Cloud OpenFeign")])])]),v._v(" "),t("p",[v._v("Feign是一个声明性的Web服务客户端。它使编写Web服务客户端变得更容易。要使用Feign，我们可以将调用的服务方法定义成抽象方法保存在本地添加一点点注解就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。")]),v._v(" "),t("h4",{attrs:{id:"spring-cloud-和dubbo区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-和dubbo区别"}},[v._v("#")]),v._v(" Spring Cloud 和dubbo区别?")]),v._v(" "),t("ul",[t("li",[v._v("服务调用方式：dubbo是RPC springcloud Rest Api")]),v._v(" "),t("li",[v._v("注册中心：dubbo 是zookeeper springcloud是eureka，也可以是zookeeper")]),v._v(" "),t("li",[v._v("服务网关，dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素")])]),v._v(" "),t("h4",{attrs:{id:"服务注册和发现是什么意思-spring-cloud-如何实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务注册和发现是什么意思-spring-cloud-如何实现"}},[v._v("#")]),v._v(" 服务注册和发现是什么意思？Spring Cloud 如何实现？")]),v._v(" "),t("p",[v._v("当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。")]),v._v(" "),t("h4",{attrs:{id:"什么是eureka"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是eureka"}},[v._v("#")]),v._v(" 什么是Eureka？")]),v._v(" "),t("p",[v._v("Eureka作为SpringCloud的服务注册功能服务器，他是服务注册中心，系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳，这样工作人员可以通过Eureka Service来监控各个微服务是否运行正常。")]),v._v(" "),t("h4",{attrs:{id:"eureka怎么实现高可用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#eureka怎么实现高可用"}},[v._v("#")]),v._v(" Eureka怎么实现高可用？")]),v._v(" "),t("p",[v._v("集群吧，注册多台Eureka，然后把SpringCloud服务互相注册，客户端从Eureka获取信息时，按照Eureka的顺序来访问。")]),v._v(" "),t("h4",{attrs:{id:"什么是eureka的自我保护模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是eureka的自我保护模式"}},[v._v("#")]),v._v(" 什么是Eureka的自我保护模式？")]),v._v(" "),t("p",[v._v("默认情况下，如果Eureka Service在一定时间内没有接收到某个微服务的心跳，Eureka Service会进入自我保护模式，在该模式下Eureka Service会保护服务注册表中的信息，不再删除注册表中的数据，当网络故障恢复后，Eureka Servic 节点会自动退出自我保护模式")]),v._v(" "),t("h4",{attrs:{id:"discoveryclient的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#discoveryclient的作用"}},[v._v("#")]),v._v(" DiscoveryClient的作用？")]),v._v(" "),t("p",[v._v("可以从注册中心中根据服务别名获取注册的服务器信息。")]),v._v(" "),t("h4",{attrs:{id:"eureka和zookeeper都可以提供服务注册与发现的功能-请说说两个的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#eureka和zookeeper都可以提供服务注册与发现的功能-请说说两个的区别"}},[v._v("#")]),v._v(" Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别？")]),v._v(" "),t("ol",[t("li",[v._v("ZooKeeper中的节点服务挂了就要选举，在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的，选举就是改微服务做了集群，必须有一台主其他的都是从")]),v._v(" "),t("li",[v._v("Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的")]),v._v(" "),t("li",[v._v("Eureka本质上是一个工程,而ZooKeeper只是一个进程")]),v._v(" "),t("li",[v._v("Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪")]),v._v(" "),t("li",[v._v("ZooKeeper保证的是CP，Eureka保证的是AP")])]),v._v(" "),t("h4",{attrs:{id:"什么是网关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是网关"}},[v._v("#")]),v._v(" 什么是网关?")]),v._v(" "),t("p",[v._v("网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。")]),v._v(" "),t("h4",{attrs:{id:"网关的作用是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网关的作用是什么"}},[v._v("#")]),v._v(" 网关的作用是什么？")]),v._v(" "),t("p",[v._v("统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等")]),v._v(" "),t("h4",{attrs:{id:"什么是spring-cloud-zuul-服务网关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring-cloud-zuul-服务网关"}},[v._v("#")]),v._v(" 什么是Spring Cloud Zuul（服务网关）？")]),v._v(" "),t("p",[v._v("Zuul是对SpringCloud提供的成熟对的路由方案，他会根据请求的路径不同，网关会定位到指定的微服务，并代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。")]),v._v(" "),t("ul",[t("li",[v._v("三个重要概念：动态路由表，路由定位，反向代理：\n"),t("ul",[t("li",[v._v("动态路由表：Zuul支持Eureka路由，手动配置路由，这俩种都支持自动更新")]),v._v(" "),t("li",[v._v("路由定位：根据请求路径，Zuul有自己的一套定位服务规则以及路由表达式匹配")]),v._v(" "),t("li",[v._v("反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在 给客户端")])])]),v._v(" "),t("li",[v._v("它可以和Eureka,Ribbon,Hystrix等组件配合使用，")]),v._v(" "),t("li",[v._v("Zuul的应用场景：\n"),t("ul",[t("li",[v._v("对外暴露，权限校验，服务聚合，日志审计等")])])])]),v._v(" "),t("h4",{attrs:{id:"网关与过滤器有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网关与过滤器有什么区别"}},[v._v("#")]),v._v(" 网关与过滤器有什么区别？")]),v._v(" "),t("p",[v._v("网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言。")]),v._v(" "),t("h4",{attrs:{id:"常用网关框架有那些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用网关框架有那些"}},[v._v("#")]),v._v(" 常用网关框架有那些？")]),v._v(" "),t("p",[v._v("Nginx、Zuul、Gateway")]),v._v(" "),t("h4",{attrs:{id:"zuul与nginx有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zuul与nginx有什么区别"}},[v._v("#")]),v._v(" Zuul与Nginx有什么区别？")]),v._v(" "),t("p",[v._v("Zuul是java语言实现的，主要为java服务提供网关服务，尤其在微服务架构中可以更加灵活的对网关进行操作。Nginx是使用C语言实现，性能高于Zuul，但是实现自定义操作需要熟悉lua语言，对程序员要求较高，可以使用Nginx做Zuul集群。")]),v._v(" "),t("h4",{attrs:{id:"既然nginx可以实现网关-为什么还需要使用zuul框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#既然nginx可以实现网关-为什么还需要使用zuul框架"}},[v._v("#")]),v._v(" 既然Nginx可以实现网关？为什么还需要使用Zuul框架?")]),v._v(" "),t("p",[v._v("Zuul是SpringCloud集成的网关，使用Java语言编写，可以对SpringCloud架构提供更灵活的服务。")]),v._v(" "),t("h4",{attrs:{id:"zuulfilter常用有那些方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zuulfilter常用有那些方法"}},[v._v("#")]),v._v(" ZuulFilter常用有那些方法?")]),v._v(" "),t("ul",[t("li",[v._v("Run()：过滤器的具体业务逻辑")]),v._v(" "),t("li",[v._v("shouldFilter()：判断过滤器是否有效")]),v._v(" "),t("li",[v._v("filterOrder()：过滤器执行顺序")]),v._v(" "),t("li",[v._v("filterType()：过滤器拦截位置")])]),v._v(" "),t("h4",{attrs:{id:"如何实现动态zuul网关路由转发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何实现动态zuul网关路由转发"}},[v._v("#")]),v._v(" 如何实现动态Zuul网关路由转发?")]),v._v(" "),t("p",[v._v("通过path配置拦截请求，通过ServiceId到配置中心获取转发的服务列表，Zuul内部使用Ribbon实现本地负载均衡和转发。")]),v._v(" "),t("h4",{attrs:{id:"zuul网关如何搭建集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zuul网关如何搭建集群"}},[v._v("#")]),v._v(" Zuul网关如何搭建集群?")]),v._v(" "),t("p",[v._v("使用Nginx的upstream设置Zuul服务集群，通过location拦截请求并转发到upstream，默认使用轮询机制对Zuul集群发送请求。")]),v._v(" "),t("h4",{attrs:{id:"ribbon是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ribbon是什么"}},[v._v("#")]),v._v(" Ribbon是什么？")]),v._v(" "),t("p",[v._v("Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法")]),v._v(" "),t("p",[v._v("Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单的说，就是在配置文件中列出后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。（有点类似Nginx）")]),v._v(" "),t("h4",{attrs:{id:"nginx与ribbon的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nginx与ribbon的区别"}},[v._v("#")]),v._v(" Nginx与Ribbon的区别？")]),v._v(" "),t("p",[v._v("Nginx是反向代理同时可以实现负载均衡，nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。")]),v._v(" "),t("h4",{attrs:{id:"ribbon底层实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ribbon底层实现原理"}},[v._v("#")]),v._v(" Ribbon底层实现原理？")]),v._v(" "),t("p",[v._v("Ribbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。")]),v._v(" "),t("h4",{attrs:{id:"loadbalanced注解的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loadbalanced注解的作用"}},[v._v("#")]),v._v(" @LoadBalanced注解的作用？")]),v._v(" "),t("p",[v._v("开启客户端负载均衡。")]),v._v(" "),t("h4",{attrs:{id:"什么是断路器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是断路器"}},[v._v("#")]),v._v(" 什么是断路器")]),v._v(" "),t("p",[v._v("当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）")]),v._v(" "),t("p",[v._v("断路器有三种状态")]),v._v(" "),t("ul",[t("li",[v._v("打开状态：一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务")]),v._v(" "),t("li",[v._v("半开状态：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭")]),v._v(" "),t("li",[v._v("关闭状态：当服务一直处于正常状态 能正常调用")])]),v._v(" "),t("h4",{attrs:{id:"什么是-hystrix"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-hystrix"}},[v._v("#")]),v._v(" 什么是 Hystrix？")]),v._v(" "),t("p",[v._v("在分布式系统，我们一定会依赖各种服务，那么这些个服务一定会出现失败的情况，就会导致雪崩，Hystrix就是这样的一个工具，防雪崩利器，它具有服务降级，服务熔断，服务隔离，监控等一些防止雪崩的技术。")]),v._v(" "),t("p",[v._v("Hystrix有四种防雪崩方式:")]),v._v(" "),t("ul",[t("li",[v._v("服务降级：接口调用失败就调用本地的方法返回一个空")]),v._v(" "),t("li",[v._v("服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息")]),v._v(" "),t("li",[v._v("服务隔离：隔离服务之间相互影响")]),v._v(" "),t("li",[v._v("服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。")])]),v._v(" "),t("h4",{attrs:{id:"什么是feign"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是feign"}},[v._v("#")]),v._v(" 什么是Feign？")]),v._v(" "),t("p",[v._v("Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易")]),v._v(" "),t("p",[v._v("他将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。")]),v._v(" "),t("h4",{attrs:{id:"springcloud有几种调用接口方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springcloud有几种调用接口方式"}},[v._v("#")]),v._v(" SpringCloud有几种调用接口方式？")]),v._v(" "),t("ul",[t("li",[v._v("Feign")]),v._v(" "),t("li",[v._v("RestTemplate")])]),v._v(" "),t("h4",{attrs:{id:"ribbon和feign调用服务的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ribbon和feign调用服务的区别"}},[v._v("#")]),v._v(" Ribbon和Feign调用服务的区别？")]),v._v(" "),t("p",[v._v("调用方式同：Ribbon需要我们自己构建Http请求，模拟Http请求然后通过RestTemplate发给其他服务，步骤相当繁琐")]),v._v(" "),t("p",[v._v("而Feign则是在Ribbon的基础上进行了一次改进，采用接口的形式，将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。")]),v._v(" "),t("h4",{attrs:{id:"什么是-spring-cloud-bus"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-spring-cloud-bus"}},[v._v("#")]),v._v(" 什么是 Spring Cloud Bus？")]),v._v(" "),t("ul",[t("li",[v._v("Spring Cloud Bus就像一个分布式执行器，用于扩展的Spring Boot应用程序的配置文件，但也可以用作应用程序之间的通信通道。")]),v._v(" "),t("li",[v._v("Spring Cloud Bus 不能单独完成通信，需要配合MQ支持")]),v._v(" "),t("li",[v._v("Spring Cloud Bus一般是配合Spring Cloud Config做配置中心的")]),v._v(" "),t("li",[v._v("Springcloud config实时刷新也必须采用SpringCloud Bus消息总线")])]),v._v(" "),t("h4",{attrs:{id:"什么是spring-cloud-config"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring-cloud-config"}},[v._v("#")]),v._v(" 什么是Spring Cloud Config?")]),v._v(" "),t("p",[v._v("Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持，可以方便的对微服务各个环境下的配置进行集中式管理。Spring Cloud Config分为Config Server和Config Client两部分。Config Server负责读取配置文件，并且暴露Http API接口，Config Client通过调用Config Server的接口来读取配置文件。")]),v._v(" "),t("h4",{attrs:{id:"分布式配置中心有那些框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式配置中心有那些框架"}},[v._v("#")]),v._v(" 分布式配置中心有那些框架？")]),v._v(" "),t("p",[v._v("Apollo、zookeeper、springcloud config。")]),v._v(" "),t("h4",{attrs:{id:"分布式配置中心的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式配置中心的作用"}},[v._v("#")]),v._v(" 分布式配置中心的作用？")]),v._v(" "),t("p",[v._v("动态变更项目配置信息而不必重新部署项目。")]),v._v(" "),t("h4",{attrs:{id:"springcloud-config-可以实现实时刷新吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springcloud-config-可以实现实时刷新吗"}},[v._v("#")]),v._v(" SpringCloud Config 可以实现实时刷新吗？")]),v._v(" "),t("p",[v._v("springcloud config实时刷新采用SpringCloud Bus消息总线。")]),v._v(" "),t("h4",{attrs:{id:"什么是spring-cloud-gateway"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring-cloud-gateway"}},[v._v("#")]),v._v(" 什么是Spring Cloud Gateway?")]),v._v(" "),t("p",[v._v("Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。")]),v._v(" "),t("p",[v._v("使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。")]),v._v(" "),t("h3",{attrs:{id:"linux"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linux"}},[v._v("#")]),v._v(" Linux")]),v._v(" "),t("h4",{attrs:{id:"什么是linux"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是linux"}},[v._v("#")]),v._v(" 什么是Linux？")]),v._v(" "),t("p",[v._v("Linux是一种基于UNIX的操作系统，最初是由Linus Torvalds引入的。它基于Linux内核，可以运行在由Intel，MIPS，HP，IBM，SPARC和Motorola制造的不同硬件平台上。Linux中另一个受欢迎的元素是它的吉祥物，一个名叫Tux的企鹅形象。")])])}),[],!1,null,null,null);t.default=r.exports}}]);